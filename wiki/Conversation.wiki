#summary Mediator that implements the flow of application and user interactions

= Introduction =
As part of Requirements Gathering, Usecases describe the interaction between an actor and the system to be build. A user initiates (start) an Usecase through events from some UI control. In response to that, the system may request information from the user in order to complete (end) the Usecase. A Usecase specifies the control of that flow.

Building an application requires implementing all Usecases. View components are needed to execute usescases and will present the user with result information. In case of RIA, typically information is needed that is provided using application services.

Class *Conversation* can be used to implement the mediation process in which user interaction, information retrieval and information presentation is coordinated. Class *Conversation* provides an implementation of a coding pattern to facilitate this. 

A conversion is a non-visual component. It encapsulates the flow of actions needed to complete a Conversation. Because it is not tied to any calling (visual) component, it can be (re)used anywhere in your application.

The following snippet shows a template that can be used to implement Conversation classes.
=== Class Template ===
{{{
public class YourUseCase extends Conversation
{
	override protected function begin():void {
		// do not forget to call this.end() in the last step of the conversation when completed with success
		// or to call this.stop() when the conversation completed with a failure
	}	
	override protected function checkPreconditions():Boolean {
		// check all variable values, raise exceptions or show warnings if values are not as specified
		// return true if conditions are met, return false otherwise
	}	
}
}}}
=== Example Flow ===
A typical basic sequence is:

  * a conversation is started by providing a Function to be called after completion
  * it checks its own preconditions and stops if that fails
  * it may inspect the shared Application Context for relevant objects
  * it asks the User (through Dialogs) for additional information if needed
  * the dialog calls back to the conversation to resume the flow
  * it checks whether the dialog was accepted or canceled
  * it asks a Service to perform some operation
  * the Service calls back to the conversation to resume the flow
  * it inspects the reply to see if it was successful
  * it stores (by key) result objects into the shared Application Context
  * any View that is bound to that key gets notified about changes
  * the conversation ends

=== Examples ===
* ConversationExampleLogin