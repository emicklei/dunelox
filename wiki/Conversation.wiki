#summary Mediator that implements the flow of application and user interactions

= Introduction =
As part of Requirements Gathering, Usecases describe the interaction between an actor and the system to be build. A user initiates (start) an Usecase through events from some UI control. In response to that, the system may request information from the user in order to complete (end) the Usecase. A Usecase specifies the control of that flow.

Building an application requires implementing all Usecases. View components are needed to execute usescases and will present the user with result information. In case of RIA, typically information is needed that is provided using application services.

Class *Conversation* can be used to implement the mediation process in which user interaction, information retrieval and information presentation is coordinated. Class *Conversation* provides an implementation of a coding pattern to facilitate this. 

A conversion is a non-visual component. It encapsulates the flow of actions needed to complete a UseCase. Because it is not tied to any calling (visual) component, it can be (re)used anywhere in your application.

=== Print Example ===
Most application require some sort of reporting functionality. Creating an invoice from your shoppingbasket is such an example. Suppose you have a print button on your main canvas that is connected to the *doPrintInvoice()* function. Instead of coding the complete flow in the main canvas, you place that behavior in the PrintInvoice conversation. This snippet below shows how to use it:
{{{
public function doPrintInvoice():void {
  var cvs:PrintInvoice = new PrintInvoice()
  cvs.setShoppingBasket(myShoppingBasket)
  cvs.setCustomer(myCustomer)
  cvs.start(handleInvoicePrinted)
}
public function handleInvoicePrinted(cvs:PrintIncoice):void {
   // printing was successful, notify the user of this
}
}}}
Clearly, you need to provide the PrintInvoice conversation with all necessay information to complete its job. The implementation of PrintInvoice will have to verify (pre-conditions) that indeed a shoppingBasket and a customer is given.

The PrintInvoice conversation is started by executing *cvs.start(handleInvoicePrinted)*. This tells the conversation to begin and which callback function to invoke when it is completed.

The following snippet shows a template that can be used to implement Conversation classes.
=== Class Template ===
{{{
public class SomeActivity extends Conversation
{
	override protected function begin():void {
		// do not forget to call this.end() in the last step of the conversation when completed with success
		// or to call this.stop() when the conversation completed with a failure
	}	
	override protected function checkPreconditions():Boolean {
		// check all variable values, raise exceptions or show warnings if values are not as specified
		// return true if conditions are met, return false otherwise
	}	
}
}}}


=== Examples ===
{{{
	public class Login extends Conversation
	{
		private var _login:String
		private var _dialog:LoginDialog;		

		override protected function begin():void {
			_dialog = LoginDialog.newFor(this.view)
			_dialog.title = NLS.text('title.login')
			_dialog.show(loginOkHandler)
		}
		private function loginOkHandler(dialog:LoginDialog):void {
			this.tryLogin(dialog.userText.text, dialog.passwordText.text)
		}
		private function tryLogin(user:String,password:String):void {
			_login = user
			// ... handle user login request by invoking a remote service...
			this.end()
		}		
	}
}}}
To start the Login conversation in the Application component.
{{{
new Login().start(this, handleLoginOk)

private function handleLoginOk(cvs:Login):void {
     current_user = cvs.login
}
}}}